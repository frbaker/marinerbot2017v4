// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "UseShooter.h"
#include <CANTalon.h>
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

UseShooter::UseShooter(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::shooter.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void UseShooter::Initialize() {
	DoNotShootIt();
	//RobotMap::shooterShooterMotor->Set(0);
}

// Called repeatedly when this Command is scheduled to run
void UseShooter::Execute() {
	ShootIt();
	//RobotMap::shooterShooterMotor->Set(0.78);
}

// Make this return true when this Command no longer needs to run execute()
bool UseShooter::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void UseShooter::End() {
	DoNotShootIt();
	//RobotMap::shooterShooterMotor->Set(0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void UseShooter::Interrupted() {
	DoNotShootIt();
	//RobotMap::shooterShooterMotor->Set(0);
}

void UseShooter::ShootIt(){
	Robot::shooter->justShootMe();
}
/*
void UseShooter::ShootIt(){
	//Robot::shooter->UsePIDOutput(0.78);
	//double currentSpeed = RobotMap::shooterShooterEncoder->GetSpeed();
	double shooterVelocity = RobotMap::shooterShooterMotor->GetPulseWidthVelocity();
	SmartDashboard::PutNumber("Shooter Velocity", shooterVelocity);
	double shooterSpeed = RobotMap::shooterShooterMotor->GetSpeed();
	SmartDashboard::PutNumber("Shooter Speed", shooterSpeed);

double difference = shooterVelocity - shooterSpeed;
SmartDashboard::PutNumber("Difference", difference);

	double motorSetSpeed = 0.67;

	//Robot::shooter->SetControlMode(CANTalon::ControlMode::kSpeed);

	if (shooterVelocity < 26000.0){ //about 300 less then expected
				motorSetSpeed = SpeedUp(motorSetSpeed);
			}
	if (shooterVelocity > 27500.0){ //about 300 more then expected
				motorSetSpeed = SlowDown(motorSetSpeed);
			}

	RobotMap::shooterShooterMotor->Set(motorSetSpeed);

}
*/
void UseShooter::DoNotShootIt(){
	RobotMap::shooterShooterMotor->Set(0);
	RobotMap::shooterShooterMotor2->Set(0);
}
double UseShooter::SpeedUp(double curSetting){
	return curSetting + .02;
}
double UseShooter::SlowDown(double curSetting){
	return curSetting - .02;
}






