// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <ctime>
#include "AutonomousCommand.h"
#include "FireBalls.h"
#include"Autonomous/Auton1.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain.get());
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() {
	//RobotMap::gearSideUltra->SetAutomaticMode(true);
	//RobotMap::nonGearSideUltra->SetAutomaticMode(true);

	autonNumber = SmartDashboard::GetNumber("autonNumber",1);
	autonSec = SmartDashboard::GetNumber("autonSeconds",0);
	autonDir = SmartDashboard::GetNumber("autonDirection",0);
	autonSpe = SmartDashboard::GetNumber("autonSpeed",0);



	double pstartTime = Timer::GetFPGATimestamp();
	//std::time_t pstartTime = std::time(0); //use for practice periods only
	startTime = pstartTime;
	SmartDashboard::PutNumber("Auton StartTime", startTime);
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	//double gearSideRange = RobotMap::gearSideUltra->GetRangeMM(); // reads the range on the ultrasonic sensor
	//double nonGearSideRange = RobotMap::nonGearSideUltra->GetRangeMM(); // reads the range on the ultrasonic sensor


	switch(autonNumber){
	case 1:
		//position 1:Blue
		new Auton1();
		auton1();

		break;
	case 2:
		//position 2:Blue
		auton2();
		break;
	case 3:
		//position 3:Blue
		auton3();
		break;
	case 4:
		//position 1:Red
		auton4();
		break;
	case 5:
		//position 2:Red
		auton5();
		break;
	case 6:
		//position 3:Red
		break;
	default:
		auton1();
		break;
}

}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}
/*void AutonomousCommand::auton1(){s
	Robot::shooter->justShootMe();

}
*/
void AutonomousCommand::auton1(){
	SmartDashboard::PutNumber("Auton Time",  Timer::GetFPGATimestamp());

	if(Timer::GetFPGATimestamp()<startTime+0.5){ // 2 seconds to turn to angle
		Robot::driveTrain->driveToAngle(90);


		//Robot::driveTrain->takeJoystickInputs(0.0, 0.0, -0.75, 0.0); //positive x value rotates clockwise
		//Robot::driveTrain->takeAutoInputs( 0.6, 0.6); // for it to turn they one must have inverted values
	}
	else{
		Robot::driveTrain->takeJoystickInputs(0.0, 0.0, 0.0, 0.0);
		//Robot::driveTrain->takeAutoInputs( 0.0, 0.0);
	}
	/*else if(std::time(0)<startTime+8){ // 6 seconds to shoot balls


		RobotMap::ballFeederBallFeederSpike->Set(Relay::kForward);
		//RobotMap::shooterShooterMotor->Set(.76);
		Robot::shooter->shootRaw();

		}
	else if(std::time(0)<startTime+10){ //2 seconds to turn to angle
		RobotMap::ballFeederBallFeederSpike->Set(Relay::kOff);
		RobotMap::shooterShooterMotor->Set(0.0);
		Robot::driveTrain->driveToAngle(15.0);
		}
	else if(std::time(0)<startTime+12){ //2 seconds drive forward
		Robot::driveTrain->takeJoystickInputs(0.1, 0.1,0.0, 0.0);
	}
	else if(std::time(0)<startTime+14){ //turn to 0 degrees
		Robot::driveTrain->takeJoystickInputs(0.0, 0.0,0.0, 0.0);
	}
	else {
		Robot::driveTrain->driveToAngle(0.0);
	}*/
}

void AutonomousCommand::auton2(){
	autonSec = SmartDashboard::GetNumber("autonSeconds",0);
		autonDir = SmartDashboard::GetNumber("autonDirection",0);
		autonSpe = SmartDashboard::GetNumber("autonSpeed",0);
	SmartDashboard::PutNumber("Auton Time",  Timer::GetFPGATimestamp());

	double speed = autonSpe/100;

	if (autonDir == 1){ //reverseDirection
		speed = speed*-1;
	}



		if(Timer::GetFPGATimestamp()<startTime+autonSec){ // 2 seconds to turn to angle
			Robot::driveTrain->takeJoystickInputs(0.0, speed, 0.0, 0.0); //positive x value rotates clockwise
			//Robot::driveTrain->takeAutoInputs( 0.6, 0.6); // for it to turn they one must have inverted values
		}
		else{
			Robot::driveTrain->takeJoystickInputs(0.0, 0.0, 0.0, 0.0);
			//Robot::driveTrain->takeAutoInputs( 0.0, 0.0);
		}
}
void AutonomousCommand::auton3(){
	if(Timer::GetFPGATimestamp()<startTime+1){
		Robot::driveTrain->driveToAngle(10.0);
	}
	else if(Timer::GetFPGATimestamp()<startTime+8){
		Robot::driveTrain->driveToAngle(15.0);
	}
	else {
		Robot::driveTrain->driveToAngle(0.0);
	}

}
void AutonomousCommand::auton4(){
	if(Timer::GetFPGATimestamp()<startTime+1){
		Robot::driveTrain->driveToAngle(10.0);
	}
	else if(Timer::GetFPGATimestamp()<startTime+8){
		Robot::driveTrain->driveToAngle(15.0);
	}
	else {
		Robot::driveTrain->driveToAngle(0.0);
	}
}
void AutonomousCommand::auton5(){
	if(Timer::GetFPGATimestamp()<startTime+1){
		Robot::driveTrain->driveToAngle(10.0);
	}
	else if(Timer::GetFPGATimestamp()<startTime+8){
		Robot::driveTrain->driveToAngle(15.0);
	}
	else {
		Robot::driveTrain->driveToAngle(0.0);
	}
}
void AutonomousCommand::auton6(){
	if(Timer::GetFPGATimestamp()<startTime+1){
		Robot::driveTrain->driveToAngle(10.0);
	}
	else if(Timer::GetFPGATimestamp()<startTime+8){
		Robot::driveTrain->driveToAngle(15.0);
	}
	else {
		Robot::driveTrain->driveToAngle(0.0);
	}
}


/*float AutonomousCommand::encoderValue(float lf_encoder, float lr_encoder, float rf_encoder, float rr_encoder, float encDistance ){

	lf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	lr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;

	rf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	rr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;


	encDistance = (lf_encoder + lr_encoder + rr_encoder + rf_encoder) / 2; //averages the values from all encoders
	return encDistance;


}
*/
