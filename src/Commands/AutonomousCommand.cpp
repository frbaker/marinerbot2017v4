// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
#include <WPILib.h>
#include <ctime>
#include "AutonomousCommand.h"
#include "FireBalls.h"
#include"Autonomous/Auton1.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain.get());

}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() {
	setAutonStep(1); // initialize on step 1
	setUsedEncDist(0.0); //our traveled distance starts at zero
	setStartTime(Timer::GetFPGATimestamp());
	setElapsedTime(0.0);
	SmartDashboard::PutNumber("Elapsed Time", 0);
	Robot::driveTrain->ResetEncoderDistance();

	//SetTimeout(15); //set a 15 second timeout
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	setElapsedTime(getStartTime());
	//setUsedEncDist(0.0);



	//if (getElapsedTime() > 35){
	if (getElapsedTime() > 15){
		setAutonStep(1); // initialize on step 1
			setUsedEncDist(0.0); //our traveled distance starts at zero
			setStartTime(Timer::GetFPGATimestamp());
			setElapsedTime(0.0);
			SmartDashboard::PutNumber("Elapsed Time", 0);
			Robot::driveTrain->ResetEncoderDistance();
		setAutonStep(1);
		Robot::driveTrain->ResetEncoderDistance();


				End();


		this->Cancel();
	}

	//Todo - this is just for testing or backup plan in case encoders
	// are not working for us - should be commented out
	//for competition (if used, should be moved to each individual case
	//as the timing will be different for each scenario)
/*
	if (getElapsedTime() < 1.5 ) {
		setAutonStep(1); //drive forward 9"
	}
	else if (getElapsedTime() >= 1.5 && getElapsedTime()<2.7){
		setAutonStep(2); //turn -90 degrees
	}
	else if (getElapsedTime() >= 2.7 && getElapsedTime()<7.7){
		setAutonStep(3); //drive 216 inches
	}
	else if (getElapsedTime() >= 7.7 && getElapsedTime()< 8.3){
		setAutonStep(4); //turn
	}
	else if (getElapsedTime() >= 8.3){
		setAutonStep(5); //fire
	}
*/

	/*if (getElapsedTime() < 4.5 ) {
		setAutonStep(1); //drive forward 9"
	}
	else if (getElapsedTime() >= 4.5 && getElapsedTime()<9.7){
		setAutonStep(2); //turn -90 degrees
	}
	else if (getElapsedTime() >= 9.7 && getElapsedTime()<14.7){
		setAutonStep(3); //drive 216 inches
	}
	else if (getElapsedTime() >= 14.7 && getElapsedTime()< 18.3){
		setAutonStep(4); //turn
	}
	else if (getElapsedTime() >= 18.3 && getElapsedTime()< 25){
		setAutonStep(5); //fire
	}
	else if (getElapsedTime() >= 25){
		setAutonStep(6); //nothing
	}
		//End of testing code
*/







	int autonNumber = SmartDashboard::GetNumber("autonNumber",1);




	switch(autonNumber){
	case 1:
		//position 1:Blue
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton1();
		break;
	case 2:
		//position 2:Blue
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton2();
		break;
	case 3:
		//position 3:Blue
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton3();
		break;
	case 4:
		//position 1:Red
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton4();
		break;
	case 5:
		//position 2:Red
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton5();
		break;
	case 6:
		//position 3:Red
		SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);
		auton6();
		break;
	case 0:
			//position 3:Red
			SmartDashboard::PutNumber("Running Autonomous Routine", autonNumber);

			break;
	default:
		SmartDashboard::PutNumber("Running Autonomous Routine", 00);
		auton1();
		break;

}

}



// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
   // return IsTimedOut();
	return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
	Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
	RobotMap::ballVibrator->Set(0.0); //stop
	Robot::shooter->shooterMotor->Set(0.0); //stop
	RobotMap::ballFeederBallFeederSpike->Set(0.0); //stop
	RobotMap::ballSubFeeder->Set(0.0); //stop
	SmartDashboard::PutNumber("Auton Step", 700);



}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}



void AutonomousCommand::setAutonStep(int nextStep){
	this->autonStep = nextStep;
	SmartDashboard::PutNumber("Auton Step", autonStep);
}
int AutonomousCommand::getAutonStep(){
	return this->autonStep;
}

void AutonomousCommand::setElapsedTime(double startTime){
	this->elapsedTime = Timer::GetFPGATimestamp() - startTime; //time since started
	SmartDashboard::PutNumber("Elapsed Time", elapsedTime);
}
double AutonomousCommand::getElapsedTime(){
	return this->elapsedTime;
}

void AutonomousCommand::setStartTime(double startTime){
	this->startTime = Timer::GetFPGATimestamp(); //just set it to the start time
	SmartDashboard::PutNumber("Start Time", this->startTime);
}
double AutonomousCommand::getStartTime(){
	return this->startTime;
}

void AutonomousCommand::setUsedEncDist(float totalDist){
	this->usedEncDist = totalDist;
}
float AutonomousCommand::getUsedEncDist(){

	return this->usedEncDist;
}

void AutonomousCommand::setUsedStrafeRightEncDist(float totalStrafeRightDist){
	this->strafeRightDist = totalStrafeRightDist;
}
float AutonomousCommand::getStrafeRightEncDist(){
	return this->strafeRightDist;
}



void AutonomousCommand::auton1(){

	/*Get the data from the pi so that we can add them into the autonomous routines*/
	double targetAcquired = SmartDashboard::GetNumber("twistDirection",1);
	double distanceAway = SmartDashboard::GetNumber("distanceAway",1);
	double deflection = SmartDashboard::GetNumber("deflection",1);

	SmartDashboard::PutNumber("Encoder Distance", Robot::driveTrain->ReturnEncoderDistance());

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 */
	if (getAutonStep() == 1){
		//SmartDashboard::PutString("Going Forward 9");
		SmartDashboard::PutString("Driving Forward", "9 Inches");
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 9){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn left till we reach -90 degrees
	 */
	if (getAutonStep() == 2){
		SmartDashboard::PutString("Turning to", "-90 degrees");
		if(RobotMap::drivegyro->GetAngle() > -90){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 */
	if (getAutonStep() == 3){
		SmartDashboard::PutString("Driving Forward", "216 Inches");
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 216){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Turn left another -36 degrees till we reach -135
	 */
	if (getAutonStep() == 4){
		SmartDashboard::PutString("Turning to", "-135 degrees");
		if(RobotMap::drivegyro->GetAngle() > -135){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		}
		else{

			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop

			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 5. Start the shooter, subshooter, ball vibrator, and x-mas tree
	 */
	//todo add a timeout
	if (getAutonStep() == 5){
		//SmartDashboard::PutString("Shooting");
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::shooter->justShootMe();
			RobotMap::ballVibrator->Set(0.25);
			RobotMap::ballFeederBallFeederSpike->Set(0.5); //the tree (no longer on a spike relay)
			RobotMap::ballSubFeeder->Set(0.75); //The subfeeder
		}
		else{
			RobotMap::ballVibrator->Set(0.0); //stop
			Robot::shooter->shooterMotor->Set(0.0); //stop
			RobotMap::ballFeederBallFeederSpike->Set(0.0); //stop
			RobotMap::ballSubFeeder->Set(0.0); //stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}
	if (getAutonStep() == 6){
		RobotMap::ballVibrator->Set(0.0); //stop
		Robot::shooter->shooterMotor->Set(0.0); //stop
		RobotMap::ballFeederBallFeederSpike->Set(0.0); //stop
		RobotMap::ballSubFeeder->Set(0.0); //stop
		Robot::driveTrain->ResetEncoderDistance();

	}

}

void AutonomousCommand::auton2(){
		/*test routine to place gear with vision*/

	/*
	 * 1. Drive Forward 60% speed for 173 inches
	 */
	if (getAutonStep() == 1){
		//SmartDashboard::PutString("Going Forward 173");
		SmartDashboard::PutString("Driving Forward", "173 Inches");
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 173){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn right till we reach 120 degrees
	 */
	if (getAutonStep() == 2){
		SmartDashboard::PutString("Turning to", "120 degrees");
		if(RobotMap::drivegyro->GetAngle() > 120){
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.3, 0.0);
		}
		else{
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Strafe Right 60% speed for 48 inches
	 */
	if (getAutonStep() == 3){

		/*Get the data from the pi so that we can add them into the autonomous routines*/
		double targetAcquired = SmartDashboard::GetNumber("twistDirection",1);
		double distanceAway = SmartDashboard::GetNumber("distanceAway",1);
		double deflection = SmartDashboard::GetNumber("deflection",1);
		double adjustZ = 0.0;

		if(Robot::driveTrain->ReturnStrafeRightEncoderDistance()-getStrafeRightEncDist() < 48){


			if(RobotMap::drivegyro->GetAngle() > 122){
				double adjustZ = -0.6;
			}
			else if(RobotMap::drivegyro->GetAngle() < 118){
				double adjustZ = 0.6;
			}


			if (distanceAway < 14){ //if we are close enough - toss the gear
				setAutonStep(getAutonStep() + 1); //go to next step
			}

			if (deflection < -4){
				//move forward and strafe
				Robot::driveTrain->autoDrive(0.6, 0.6, adjustZ, RobotMap::drivegyro->GetAngle());

			}
			else if (deflection > 4){
				//move backwards and strafe
				Robot::driveTrain->autoDrive(0.6, -0.6, adjustZ, RobotMap::drivegyro->GetAngle());
			}
			else{
				//strafe straight slideways
				Robot::driveTrain->autoDrive(0.6, 0.0, adjustZ, RobotMap::drivegyro->GetAngle());
			}

		SmartDashboard::PutString("Strafing Right 48",  "48 Inches");
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			//Robot::driveTrain->autoDrive(0.6, 0.0, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			Robot::driveTrain->autoDrive(0.0, 0.0, 0.0, 0.0); //full stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Toss the gear on the ground
	 */
	if (getAutonStep() == 4){
		SmartDashboard::PutString("Tossing Gear", "Yea Boi!");
		Robot::gearMover->TossGear();
		setAutonStep(getAutonStep() + 1); //go to next step

	}

	/*
	 * 5. Start the shooter, subshooter, ball vibrator, and x-mas tree
	 */
	//todo add a timeout
	if (getAutonStep() == 5){
		//SmartDashboard::PutString("Shooting");
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::shooter->justShootMe();
			RobotMap::ballVibrator->Set(0.25);
			RobotMap::ballFeederBallFeederSpike->Set(0.5); //the tree (no longer on a spike relay)
			RobotMap::ballSubFeeder->Set(0.75); //The subfeeder
		}
		else{
			RobotMap::ballVibrator->Set(0.0); //stop
			Robot::shooter->shooterMotor->Set(0.0); //stop
			RobotMap::ballFeederBallFeederSpike->Set(0.0); //stop
			RobotMap::ballSubFeeder->Set(0.0); //stop
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}
	if (getAutonStep() == 6){
		RobotMap::ballVibrator->Set(0.0); //stop
		Robot::shooter->shooterMotor->Set(0.0); //stop
		RobotMap::ballFeederBallFeederSpike->Set(0.0); //stop
		RobotMap::ballSubFeeder->Set(0.0); //stop
	}

}
void AutonomousCommand::auton3(){
	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 */
	if (getAutonStep() == 1){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 9){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn left till we reach -90 degrees
	 */
	if (getAutonStep() == 2){
		if(RobotMap::drivegyro->GetAngle() > -90){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 */
	if (getAutonStep() == 3){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 216){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	if (getAutonStep() == 4){
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
}
}
void AutonomousCommand::auton4(){
	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 */
	if (getAutonStep() == 1){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 9){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn left till we reach -90 degrees
	 */
	if (getAutonStep() == 2){
		if(RobotMap::drivegyro->GetAngle() > -90){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 */
	if (getAutonStep() == 3){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 216){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	if (getAutonStep() == 4){
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
}
}
void AutonomousCommand::auton5(){
	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 */
	if (getAutonStep() == 1){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 9){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn left till we reach -90 degrees
	 */
	if (getAutonStep() == 2){
		if(RobotMap::drivegyro->GetAngle() > -90){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 */
	if (getAutonStep() == 3){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 216){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	if (getAutonStep() == 4){
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
}
}
void AutonomousCommand::auton6(){
	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 */
	if (getAutonStep() == 1){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 9){
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else {
			setAutonStep(getAutonStep() + 1);  //go to next step
			SmartDashboard::PutNumber("Routine1 End1 EncDist", getUsedEncDist()); //show us the average encoder distance values
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 1
		}
	}

	/*
	 * 2. Turn left till we reach -90 degrees
	 */
	if (getAutonStep() == 2){
		if(RobotMap::drivegyro->GetAngle() > -90){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
	}

	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 */
	if (getAutonStep() == 3){
		if(Robot::driveTrain->ReturnEncoderDistance()-getUsedEncDist() < 216){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 3
		}
	}

	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	if (getAutonStep() == 4){
		if(RobotMap::drivegyro->GetAngle() > -126){
			Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);
		}
		else{
			setAutonStep(getAutonStep() + 1); //go to next step
			SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
			SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
			setUsedEncDist(Robot::driveTrain->ReturnEncoderDistance()); //record used Encoder Distance at end of step 2
		}
}
}


/*float AutonomousCommand::encoderValue(float lf_encoder, float lr_encoder, float rf_encoder, float rr_encoder, float encDistance ){

	lf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	lr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;

	rf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	rr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;


	encDistance = (lf_encoder + lr_encoder + rr_encoder + rf_encoder) / 2; //averages the values from all encoders
	return encDistance;


}
*/
