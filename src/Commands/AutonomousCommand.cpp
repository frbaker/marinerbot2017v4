// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <ctime>
#include "AutonomousCommand.h"
#include "FireBalls.h"
#include"Autonomous/Auton1.h"




// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain.get());

}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() {






	double startTime = Timer::GetFPGATimestamp();
	//std::time_t pstartTime = std::time(0); //use for practice periods only
	SmartDashboard::PutNumber("Auton StartTime", startTime);
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	//double gearSideRange = RobotMap::gearSideUltra->GetRangeMM(); // reads the range on the ultrasonic sensor
	//double nonGearSideRange = RobotMap::nonGearSideUltra->GetRangeMM(); // reads the range on the ultrasonic sensor

	int autonNumber = SmartDashboard::GetNumber("autonNumber",1);

	switch(autonNumber){
	case 1:
		//position 1:Blue
		auton1();
		break;
	case 2:
		//position 2:Blue
		auton2();
		break;
	case 3:
		//position 3:Blue
		auton3();
		break;
	case 4:
		//position 1:Red
		auton4();
		break;
	case 5:
		//position 2:Red
		auton5();
		break;
	case 6:
		//position 3:Red
		break;
	default:
		auton1();
		break;
}

}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}
/*void AutonomousCommand::auton1(){s
	Robot::shooter->justShootMe();

}
*/
void AutonomousCommand::auton1(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+3.0){
				break;
			}
	}



}

void AutonomousCommand::auton2(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+3.0){
				break;
			}
	}



}
void AutonomousCommand::auton3(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+3.0){
				break;
			}
	}




}
void AutonomousCommand::auton4(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+15.0){
				break;
			}
	}
	/*
	 * 5. Shoot it up
	 *
	 */
	while (Timer::GetFPGATimestamp()<startTime+25.0){
		//also need to start ball vibrator and x-mas tree
		Robot::shooter->justShootMe();

	}

}
void AutonomousCommand::auton5(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+3.0){
				break;
			}
	}



}
void AutonomousCommand::auton6(){
	double startTime = Timer::GetFPGATimestamp();
	float usedEncDist = 0.0;
	//Initially our encoder Distance should start at null, 0, nada, nothing

	/*
	 * 1. Drive Forward 60% speed for 9 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+3.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End1 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 2. Turn left till we reach -90 degrees
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -90){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+5.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End2 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End2 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 3. Drive Forward 60% speed for 216 inches
	 *
	 */
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 216){
		//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
		Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+10.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End3 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();


	/*
	 * 4. Turn left another -36 degrees till we reach -126
	 *
	 */
	while(RobotMap::drivegyro->GetAngle() > -126){
		//question? - will this actually turn left?
		Robot::driveTrain->autoDrive(0.0, 0.0, -0.3, 0.0);

		//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
		if (Timer::GetFPGATimestamp()<startTime+12.0){
			break;
		}
	}
	SmartDashboard::PutNumber("Routine1 End4 EncDist", Robot::driveTrain->ReturnEncoderDistance());
	SmartDashboard::PutNumber("Routine1 End4 Angle", RobotMap::drivegyro->GetAngle());
	usedEncDist = Robot::driveTrain->ReturnEncoderDistance();
	while(Robot::driveTrain->ReturnEncoderDistance()-usedEncDist < 9){
			//get our current encDistance - should add a sanity check to keep from looping forever if we don't get a sensor reading
			Robot::driveTrain->autoDrive(0.0, 0.6, 0.0, RobotMap::drivegyro->GetAngle());

			//Sanity Check - This should never take more then X seconds - if it does, break out of the loop
			if (Timer::GetFPGATimestamp()<startTime+3.0){
				break;
			}
	}



}


/*float AutonomousCommand::encoderValue(float lf_encoder, float lr_encoder, float rf_encoder, float rr_encoder, float encDistance ){

	lf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	lr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;

	rf_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;
	rr_encoder = RobotMap::driveTrainLf->GetEncPosition()*25.12;


	encDistance = (lf_encoder + lr_encoder + rr_encoder + rf_encoder) / 2; //averages the values from all encoders
	return encDistance;


}
*/
